from glob import glob
import json
import os
import signal
import socket
import subprocess
import threading
import time
import warnings
import redis

from agentworker import (
    EmulationStatus,
    WorkerStatus
)
from agentworker.config import Config

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))


def get_ip_address():
    get_s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    get_s.connect(('8.8.8.8', 0))

    ip_table = 'ip:{}'.format(get_s.getsockname()[0])
    get_s.close()

    return ip_table


def init_table(r, ip):
    """
        Initialize redis table by given ip address.

        Args:
            ip: The id address of current machine.

        Return:
            True, if the initialization is successful, otherwise False.
    """
    try:
        r.set("stop_agentworker", "")
        r.hset(ip, "device_name", "")
        r.hset(ip, "device_settings", "")
        r.hset(ip, "worker_status", WorkerStatus.WAIT)
    except Exception as e:
        print("init_table error", e)
        return False


def heartbeat(r, ip):
    """
        Check if redis is alive per second.
    """
    try:
        while not bool(r.get("stop_agentworker")):
            # Get nanoseconds
            now = "{:.20f}".format(time.time())
            r.hset(ip, "time", "{}".format(now))
            time.sleep(1)
    except Exception as e:
        print("heartbeat error:", (e))
        raise Exception("heartbeat error:", (e))


def remove_old_log():
    """
    Remove all log which generated by previous emulation.
    """
    try:
        DELETED_LOG_PATH = "{}/*.json".format(Config.REPORT_PATH)
        for log in glob(DELETED_LOG_PATH):
            if os.path.exists(log):
                os.remove(log)
    except Exception as e:
        print("remove old log error", e)


def generate_dds_descriptive_file(r, ip):
    """
        Args:
            r: Redis instance.
            ip: Specific ip.
    """
    try:
        device_name = r.hget(ip, "device_name")
        device_settings = json.loads(r.hget(ip, "device_settings"))
        emulation_time = int(r.get("emulation_time"))

        dds_file = {
            "name": device_name,
            "experiment_time": emulation_time,
            "measure_count": 100,
            "domain": device_settings["domain"],
        }

        dds_file_path = os.path.join(
            CURRENT_DIR, Config.DATASETTING_PATH, "dds_descriptive_file.json")
        with open(dds_file_path, "w") as outputfile:
            json.dump(dds_file, outputfile)
    except Exception as e:
        print("generate_dds_descriptive_file error: ", e)


def remove_emulation_signal():
    if os.path.isfile(Config.DDS_READY_PATH):
        os.remove(Config.DDS_READY_PATH)
    if os.path.isfile(Config.DDS_START_PATH):
        os.remove(Config.DDS_START_PATH)


def dds_is_ready():
    return os.path.isfile(Config.DDS_READY_PATH)


def set_dds_start():
    with open(Config.DDS_START_PATH, "w") as f:
        f.write("start\n")


def execute_dds(r, ip):
    """
        Args:
            r: Redis instance.
            ip: Specific ip.
    """
    cmd = Config.DDS_PATH
    result = True
    is_start = False
    remove_emulation_signal()

    print("Wait for releasing resource")
    time.sleep(15)

    try:
        sys_env = os.environ.copy()
        proc = subprocess.Popen(cmd, shell=False, env=sys_env, preexec_fn=os.setsid)
        print("Run emulation.")
        while proc.poll() is None:
            print("execute subprocess")
            if dds_is_ready():
                r.hset(ip, "worker_status", WorkerStatus.READY)
                os.remove(Config.DDS_READY_PATH)

            emulation_status = r.get("emulation_status")
            if emulation_status == EmulationStatus.START and not is_start:
                print("DDS start.")
                set_dds_start()
                is_start = True
            elif emulation_status == EmulationStatus.ABORT:
                print("Abort emulation.")
                r.hset(ip, "worker_status", WorkerStatus.WAIT)
                proc.terminate()
                proc.wait()

                result = False
                break
            time.sleep(1)
        return result
    except Exception as e:
       print("Execute dds error:", e)


def load_json(path):
    with open(path, 'r') as inputfile:
        data = json.load(inputfile)
    return data


def save_report(r, ip):
    try:
        report = {}
        for filename in os.listdir(Config.REPORT_PATH):
            if 'json' in filename:
                path = os.path.join(Config.REPORT_PATH, filename)
                data = load_json(path)
        r.hset(ip, 'device_report', json.dumps(data))
    except Exception as e:
        print("Trainsmit result to frontend error: ", e)


def wait_emulation_end(r):
    """
        r: Redis instance.
    """
    try:
        while True:
            result = r.get('emulation_status')
            if (result == EmulationStatus.END or
                    result == EmulationStatus.EXCEPTION or
                    result == EmulationStatus.ABORT):
                print("emulation end.")
                break
            else:
                time.sleep(1)
    except Exception as e:
        print('wait emulation end error: ', e)


def main():
    print("Agent worker start")
    r = redis.StrictRedis(host=Config.SERVER_IP, port=Config.REDIS_PORT, password=Config.REDIS_PASSWORD, 
        encoding="utf-8",decode_responses=True)

    try:
        ip = get_ip_address()
        init_table(r, ip)
        thread_heartbeat = threading.Thread(target=heartbeat, name="heartbeat", args=(r, ip,))
        thread_heartbeat.daemon = True
        thread_heartbeat.start()

        while not bool(r.get("stop_agentworker")):
            if r.hget(ip, "worker_status") == WorkerStatus.WAIT:
                print("wait")
            elif r.hget(ip, "worker_status") == WorkerStatus.PREPARE:
                remove_old_log()
                generate_dds_descriptive_file(r, ip)
                print("Generating dds descriptive file is finish.")
                if execute_dds(r, ip) is True:
                    print("transmit result")
                    save_report(r, ip)

                r.hset(ip, "worker_status", WorkerStatus.DONE)
                wait_emulation_end(r)

            time.sleep(1)
    except Exception as e:
        r.hset(ip, "worker_status", WorkerStatus.EXCEPTION)
        print("error", e)

if __name__ == "__main__":
    main()
